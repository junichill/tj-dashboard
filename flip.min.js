!function() {
    "use strict";

    function l(t) {
        return "function" == typeof t || "[object Function]" === e.call(t);
    }

    function s(t) {
        t = function(t) {
            t = Number(t);
            return isNaN(t) ? 0 : 0 !== t && isFinite(t) ? (0 < t ? 1 : -1) * Math.floor(Math.abs(t)) : t;
        }(t);
        return Math.min(Math.max(t, 0), n);
    }

    var e, n, i, o, a, u;

    Array.prototype.fill || Object.defineProperty(Array.prototype, "fill", {
        value: function(t) {
            if (null == this) throw new TypeError("this is null or not defined");
            for (var e = Object(this), n = e.length >>> 0, r = arguments[1] >> 0, i = r < 0 ? Math.max(n + r, 0) : Math.min(r, n), r = arguments[2], r = void 0 === r ? n : r >> 0, o = r < 0 ? Math.max(n + r, 0) : Math.min(r, n); i < o;)
                e[i] = t, i++;
            return e;
        }
    });

    Array.prototype.find || Object.defineProperty(Array.prototype, "find", {
        value: function(t) {
            if (null == this) throw new TypeError("Array.prototype.find called on null or undefined");
            if ("function" != typeof t) throw new TypeError("predicate must be a function");
            for (var e = Object(this), n = e.length >>> 0, r = arguments[1], i = 0; i !== n; i++)
                if (t.call(r, this[i], i, e)) return this[i];
        }
    });

    Array.from || (Array.from = (e = Object.prototype.toString,
        n = Math.pow(2, 53) - 1,
        function(t) {
            var e = Object(t);
            if (null == t) throw new TypeError("Array.from requires an array-like object - not null or undefined");
            var n, r = 1 < arguments.length ? arguments[1] : void 0;
            if (void 0 !== r) {
                if (!l(r)) throw new TypeError("Array.from: when provided, the second argument must be a function");
                2 < arguments.length && (n = arguments[2]);
            }
            for (var i, o = s(e.length), a = l(this) ? Object(new this(o)) : new Array(o), u = 0; u < o;)
                i = e[u],
                a[u] = r ? void 0 === n ? r(i, u) : r.call(n, i, u) : i,
                u += 1;
            return a.length = o, a;
        }));

    Array.prototype.includes = Array.prototype.includes || function(t, e) {
        if (!this) throw new TypeError("Array.prototype.includes called on null or undefined");
        if (void 0 === e) {
            for (var n = this.length; n--;)
                if (this[n] === t) return !0;
        } else
            for (var n = e, r = this.length; n++ !== r;)
                if (this[n] === t) return !0;
        return !1;
    };

    "function" != typeof Object.assign && (Object.assign = function(t, e) {
        if (null == t) throw new TypeError("Cannot convert undefined or null to object");
        for (var n = Object(t), r = 1; r < arguments.length; r++) {
            var i = arguments[r];
            if (null != i)
                for (var o in i)
                    Object.prototype.hasOwnProperty.call(i, o) && (n[o] = i[o]);
        }
        return n;
    });

    Object.keys || (Object.keys = (i = Object.prototype.hasOwnProperty,
        o = !{ toString: null }.propertyIsEnumerable("toString"),
        u = (a = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"]).length,
        function(t) {
            if ("object" != typeof t && ("function" != typeof t || null === t)) throw new TypeError("Object.keys called on non-object");
            var e, n, r = [];
            for (e in t) i.call(t, e) && r.push(e);
            if (o)
                for (n = 0; n < u; n++) i.call(t, a[n]) && r.push(a[n]);
            return r;
        }));

}();
